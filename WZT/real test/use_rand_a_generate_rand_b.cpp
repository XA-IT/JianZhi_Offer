// 使用函数rand5()来实现函数rand7()

// 我们先给出一个组合，再来进行分析。组合如下：

// 5 * (Rand5() - 1) + Rand5()
// Rand5产生1到5的数，减1就产生0到4的数，乘以5后可以产生的数是：0,5,10,15,20。 
// 再加上第二个Rand5()产生的1,2,3,4,5。
// 我们可以得到1到25， 而且每个数都只由一种组合得到，即上述代码可以等概率地生成1到25。

int Rand7(){
    int x = ~(1<<31); // max int
    while(x > 7)
        x = 5 * (Rand5() - 1) + Rand5() // Rand25
    return x;
}

// 上面的代码有什么问题呢？可能while循环要进行很多次才能返回。 
// 因为Rand25会产生1到25的数，而只有1到7时才跳出while循环， 生成大部分的数都舍弃掉了。
// 这样的实现明显不好。我们应该让舍弃的数尽量少，于是我们可以修改while中的判断条件，
// 让x与最接近25且小于25的7的倍数相比。 
// 于是判断条件可改为x > 21，于是x的取值就是1到21。 我们再通过取模运算把它映射到1-7即可。

// 1. 如果a > b，进入步骤2；否则构造Randa2 = a * (Randa – 1) + Randa， 
// 表示生成1到a2 随机数的函数。如果a2 仍小于b，继教构造 Randa3 = a * (Randa2 – 1) + Randa…
// 直到ak > b，这时我们得到Randak , 我们记为RandA。

// 2. 步骤1中我们得到了RandA(可能是Randa或Randak )，其中A > b， 我们用下述代码构造Randb：

// A > b

// 从上面一系列的分析可以发现，如果给你两个生成随机数的函数Randa和Randb，
// 你可以通过以下方式轻松构造Randab，生成1到a*b的随机数。

// Randab = b * (Randa - 1) + Randb
// Randab = a * (Randb - 1) + Randa
